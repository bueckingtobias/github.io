<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BTC KPI Modul (mit Chart)</title>
  <style>
    :root{
      --bg: #0b0f17;
      --card: rgba(255,255,255,.08);
      --card2: rgba(255,255,255,.12);
      --stroke: rgba(255,255,255,.14);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.62);
      --good: #34C759;
      --bad: #FF3B30;
    }
    *{box-sizing:border-box}
    body{
      margin:0; min-height:100vh; display:grid; place-items:center;
      background: radial-gradient(1200px 800px at 20% 10%, #1b2a55 0%, transparent 55%),
                  radial-gradient(900px 700px at 80% 30%, #1f4a3c 0%, transparent 60%),
                  linear-gradient(180deg, #070a10 0%, #0b0f17 100%);
      color:var(--text);
      font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "SF Pro Display","SF Pro Text", "Segoe UI", Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    .btc-kpi{
      width:min(560px, calc(100vw - 24px));
      border:1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      border-radius:18px;
      box-shadow: 0 18px 60px rgba(0,0,0,.45);
      overflow:hidden;
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
    }
    .hdr{
      padding:14px 16px 10px 16px;
      display:flex; align-items:center; justify-content:space-between; gap:12px;
    }
    .title{
      display:flex; align-items:center; gap:10px; font-weight:600; letter-spacing:.2px;
    }
    .dot{
      width:10px; height:10px; border-radius:999px; background:#f2a900;
      box-shadow: 0 0 0 6px rgba(242,169,0,.12);
    }
    .sub{ font-size:12px; color:var(--muted); }
    .tabs{ display:flex; gap:6px; padding:0 10px 10px 10px; }
    .tab{
      border:1px solid var(--stroke);
      background: rgba(255,255,255,.06);
      color:var(--muted);
      padding:8px 10px;
      border-radius:12px;
      font-size:13px;
      cursor:pointer;
      user-select:none;
      transition: transform .12s ease, background .12s ease, color .12s ease;
    }
    .tab:hover{ transform: translateY(-1px); background: rgba(255,255,255,.08); color: rgba(255,255,255,.78); }
    .tab[aria-selected="true"]{
      background: rgba(255,255,255,.14);
      color: var(--text);
      border-color: rgba(255,255,255,.22);
    }
    .body{ padding: 6px 16px 16px 16px; display:grid; gap:10px; }
    .err{
      padding:12px 14px; border-radius:14px;
      border:1px solid rgba(255,59,48,.28);
      background: rgba(255,59,48,.12);
      color: rgba(255,255,255,.88);
      display:none;
      font-size:13px;
    }
    .kpi{
      display:grid;
      grid-template-columns: 1fr;
      gap:10px;
      padding:14px 14px;
      border-radius:16px;
      background: rgba(0,0,0,.22);
      border: 1px solid rgba(255,255,255,.10);
    }
    .kpi-top{
      display:flex; align-items:flex-end; justify-content:space-between; gap:12px;
    }
    .price{
      font-size:34px; font-weight:700; letter-spacing:-.4px; line-height:1.1;
    }
    .meta{
      text-align:right;
      display:flex; flex-direction:column; gap:8px;
      font-size:12px; color:var(--muted);
      min-width: 190px;
    }
    .row{
      display:flex; align-items:center; justify-content:flex-end; gap:8px;
    }
    .pill{
      display:inline-flex; align-items:center; gap:6px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: var(--text);
      font-size:12px;
      font-weight:600;
      justify-content:flex-end;
      min-width: 92px;
    }
    .pill.good{ border-color: rgba(52,199,89,.35); background: rgba(52,199,89,.12); }
    .pill.bad{ border-color: rgba(255,59,48,.35); background: rgba(255,59,48,.12); }

    .chart-wrap{
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      overflow:hidden;
      position:relative;
      height: 140px;
    }
    canvas{ width:100%; height:100%; display:block; }
    .chart-label{
      position:absolute; inset:auto 10px 10px auto;
      font-size:11px; color: rgba(255,255,255,.55);
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      padding:6px 8px; border-radius:999px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    .foot{
      padding: 10px 16px 14px 16px;
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      border-top: 1px solid rgba(255,255,255,.10);
      color: var(--muted);
      font-size:12px;
    }
    .btn{
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding:8px 10px;
      border-radius:12px;
      cursor:pointer;
      font-size:12px;
      transition: transform .12s ease, background .12s ease;
    }
    .btn:hover{ transform: translateY(-1px); background: rgba(255,255,255,.10); }
  </style>
</head>
<body>

  <!--
    Standalone Modul:
    - Live Price + 24h % + 24h absolut Δ
    - Chart: letzte 24h (aus CoinGecko market_chart)
    - Abgreifen:
      window.BTCWidget.getState()
      document.addEventListener("btc-kpi-update", (e)=>{ ... e.detail ... })
  -->
  <section id="btc-kpi-module" class="btc-kpi" role="region" aria-label="Bitcoin KPI">
    <div class="hdr">
      <div>
        <div class="title"><span class="dot"></span>Bitcoin <span class="sub">Live KPI</span></div>
        <div class="sub" id="btc-status">Initialisiere…</div>
      </div>
      <button class="btn" id="btc-refresh" type="button">Aktualisieren</button>
    </div>

    <div class="tabs" role="tablist" aria-label="Währungsauswahl">
      <button class="tab" role="tab" aria-selected="true"  data-vs="eur">EUR</button>
      <button class="tab" role="tab" aria-selected="false" data-vs="usd">USD</button>
    </div>

    <div class="body">
      <div class="err" id="btc-error"></div>

      <div class="kpi" aria-live="polite">
        <div class="kpi-top">
          <div>
            <div class="sub" id="btc-label">Kurs (EUR)</div>
            <div class="price" id="btc-price">—</div>
          </div>

          <div class="meta">
            <div class="row">
              <span class="sub">24h %</span>
              <span class="pill" id="btc-chg-pct">—</span>
            </div>
            <div class="row">
              <span class="sub">24h Δ</span>
              <span class="pill" id="btc-chg-abs">—</span>
            </div>
            <div class="sub">Quelle: CoinGecko</div>
          </div>
        </div>

        <div class="chart-wrap" aria-label="Bitcoin Chart letzte 24 Stunden">
          <canvas id="btc-chart" width="1000" height="320"></canvas>
          <div class="chart-label" id="btc-chart-label">24h</div>
        </div>
      </div>
    </div>

    <div class="foot">
      <div>Letztes Update: <span id="btc-updated">—</span></div>
      <div class="sub">Auto-Refresh: <span id="btc-interval">15s</span></div>
    </div>
  </section>

  <script>
    (function(){
      const el = (id) => document.getElementById(id);

      const state = {
        vs: "eur",
        price: null,
        change24hPct: null,
        change24hAbs: null,
        chart24h: [],          // [{t, p}]
        updatedAt: null,
        source: "CoinGecko"
      };

      const fmt0 = new Intl.NumberFormat(undefined, { maximumFractionDigits: 0 });
      const fmt2 = new Intl.NumberFormat(undefined, { maximumFractionDigits: 2 });

      function sym(vs){ return vs === "eur" ? "€" : "$"; }

      function setTab(vs){
        state.vs = vs;
        document.querySelectorAll('.tab').forEach(btn=>{
          const active = btn.dataset.vs === vs;
          btn.setAttribute('aria-selected', active ? 'true' : 'false');
        });
        el('btc-label').textContent = `Kurs (${vs.toUpperCase()})`;
        render();
      }

      function setPill(pillEl, valueNumber, formatter, isMoney){
        pillEl.classList.remove('good','bad');
        if (typeof valueNumber === "number" && Number.isFinite(valueNumber)) {
          const v = valueNumber;
          const sign = v >= 0 ? "+" : "";
          const text = isMoney
            ? `${sign}${sym(state.vs)} ${fmt0.format(v)}`
            : `${sign}${formatter.format(v)}%`;
          pillEl.textContent = text;
          pillEl.classList.add(v >= 0 ? 'good' : 'bad');
        } else {
          pillEl.textContent = "—";
        }
      }

      function render(){
        const vs = state.vs;

        if (typeof state.price === "number") {
          el('btc-price').textContent = `${sym(vs)} ${fmt0.format(state.price)}`;
          el('btc-status').textContent = "Live";
        } else {
          el('btc-price').textContent = "—";
        }

        setPill(el('btc-chg-pct'), state.change24hPct, fmt2, false);
        setPill(el('btc-chg-abs'), state.change24hAbs, fmt2, true);

        el('btc-updated').textContent = state.updatedAt
          ? new Date(state.updatedAt).toLocaleTimeString()
          : "—";

        drawChart(el('btc-chart'), state.chart24h);

        // Expose + Event
        window.BTCWidget = window.BTCWidget || {};
        window.BTCWidget.getState = () => ({...state, chart24h: [...state.chart24h]});
        document.dispatchEvent(new CustomEvent("btc-kpi-update", { detail: window.BTCWidget.getState() }));
      }

      function nearestIndex(points, targetTs){
        // points: [{t,p}] sorted
        let lo = 0, hi = points.length - 1;
        while (lo < hi) {
          const mid = (lo + hi) >> 1;
          if (points[mid].t < targetTs) lo = mid + 1; else hi = mid;
        }
        const i = lo;
        if (i <= 0) return 0;
        if (i >= points.length) return points.length - 1;
        const prev = points[i-1], cur = points[i];
        return (Math.abs(prev.t - targetTs) <= Math.abs(cur.t - targetTs)) ? (i-1) : i;
      }

      async function fetchBTC(){
        const vs = state.vs;
        const base = "https://api.coingecko.com/api/v3";

        // 1) Current price + 24h % (simple/price)
        const url1 =
          `${base}/simple/price` +
          `?ids=bitcoin&vs_currencies=eur,usd&include_24hr_change=true`;

        // 2) Chart data (market_chart) - last 2 days to reliably compute "now-24h"
        const url2 =
          `${base}/coins/bitcoin/market_chart` +
          `?vs_currency=${encodeURIComponent(vs)}` +
          `&days=2&interval=hourly`;

        el('btc-error').style.display = "none";
        el('btc-status').textContent = "Update…";

        try{
          const [r1, r2] = await Promise.all([
            fetch(url1, { cache: "no-store" }),
            fetch(url2, { cache: "no-store" })
          ]);
          if(!r1.ok) throw new Error(`Price HTTP ${r1.status}`);
          if(!r2.ok) throw new Error(`Chart HTTP ${r2.status}`);

          const d1 = await r1.json();
          const d2 = await r2.json();

          const price = d1?.bitcoin?.[vs];
          const chgPct = d1?.bitcoin?.[`${vs}_24h_change`];

          const pricesArr = Array.isArray(d2?.prices) ? d2.prices : null; // [ [ts, price], ... ]
          if (typeof price !== "number") throw new Error("Unerwartete API-Antwort (Preis fehlt).");
          if (!pricesArr || pricesArr.length < 10) throw new Error("Unerwartete API-Antwort (Chart-Daten fehlen).");

          // Build 24h series (take last ~24h from returned 2d hourly data)
          const now = Date.now();
          const since = now - 24*60*60*1000;

          const pointsAll = pricesArr.map(x => ({ t: x[0], p: x[1] })).filter(p => typeof p.p === "number");
          // ensure sorted
          pointsAll.sort((a,b)=>a.t-b.t);

          // Slice to last 24h (keep a bit of buffer)
          const points24h = pointsAll.filter(pt => pt.t >= since - 60*60*1000);
          // Compute absolute delta: current - price ~24h ago (nearest point)
          const idx24 = nearestIndex(pointsAll, since);
          const p24 = pointsAll[idx24]?.p;
          const chgAbs = (typeof p24 === "number") ? (price - p24) : null;

          state.price = price;
          state.change24hPct = (typeof chgPct === "number") ? chgPct : null;
          state.change24hAbs = (typeof chgAbs === "number") ? chgAbs : null;
          state.chart24h = points24h;
          state.updatedAt = now;

          render();
        } catch(err){
          el('btc-status').textContent = "Offline";
          const box = el('btc-error');
          box.textContent =
            "Konnte BTC-Kurs/Chart gerade nicht laden. " +
            "Wenn du in einem restriktiven HTML-Tester bist: evtl. blockiert der Fetch/CORS. " +
            `Details: ${err.message}`;
          box.style.display = "block";
        }
      }

      function drawChart(canvas, points){
        const ctx = canvas.getContext("2d");
        const W = canvas.width, H = canvas.height;

        // Clear
        ctx.clearRect(0,0,W,H);

        // Empty
        if (!points || points.length < 2) {
          // subtle placeholder
          ctx.globalAlpha = 0.6;
          ctx.fillStyle = "rgba(255,255,255,0.08)";
          ctx.fillRect(0,0,W,H);
          ctx.globalAlpha = 1;
          return;
        }

        const pad = 18;
        const x0 = pad, y0 = pad, x1 = W - pad, y1 = H - pad;

        let minP = Infinity, maxP = -Infinity;
        for (const pt of points){ if (pt.p < minP) minP = pt.p; if (pt.p > maxP) maxP = pt.p; }
        if (!Number.isFinite(minP) || !Number.isFinite(maxP)) return;

        // Expand range slightly so it breathes
        const span = (maxP - minP) || 1;
        minP -= span * 0.08;
        maxP += span * 0.08;

        const tMin = points[0].t;
        const tMax = points[points.length - 1].t;

        const X = (t) => x0 + ( (t - tMin) / (tMax - tMin || 1) ) * (x1 - x0);
        const Y = (p) => y1 - ( (p - minP) / (maxP - minP || 1) ) * (y1 - y0);

        // Background grid (very light)
        ctx.lineWidth = 1;
        ctx.strokeStyle = "rgba(255,255,255,0.06)";
        for (let i=1;i<=3;i++){
          const y = y0 + (i/4)*(y1-y0);
          ctx.beginPath(); ctx.moveTo(x0, y); ctx.lineTo(x1, y); ctx.stroke();
        }

        // Path
        ctx.beginPath();
        ctx.moveTo(X(points[0].t), Y(points[0].p));
        for (let i=1;i<points.length;i++){
          ctx.lineTo(X(points[i].t), Y(points[i].p));
        }

        // Area fill
        const area = new Path2D();
        area.moveTo(X(points[0].t), Y(points[0].p));
        for (let i=1;i<points.length;i++) area.lineTo(X(points[i].t), Y(points[i].p));
        area.lineTo(X(points[points.length-1].t), y1);
        area.lineTo(X(points[0].t), y1);
        area.closePath();

        const grad = ctx.createLinearGradient(0, y0, 0, y1);
        grad.addColorStop(0, "rgba(255,255,255,0.16)");
        grad.addColorStop(1, "rgba(255,255,255,0.02)");
        ctx.fillStyle = grad;
        ctx.fill(area);

        // Stroke
        ctx.lineWidth = 2;
        ctx.strokeStyle = "rgba(255,255,255,0.72)";
        ctx.stroke();

        // Last dot
        const last = points[points.length-1];
        const lx = X(last.t), ly = Y(last.p);
        ctx.fillStyle = "rgba(255,255,255,0.92)";
        ctx.beginPath(); ctx.arc(lx, ly, 3.5, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "rgba(255,255,255,0.28)";
        ctx.beginPath(); ctx.arc(lx, ly, 9, 0, Math.PI*2); ctx.fill();
      }

      // Wiring
      document.querySelectorAll('.tab').forEach(btn=>{
        btn.addEventListener('click', ()=>{
          setTab(btn.dataset.vs);
          fetchBTC();
        });
      });
      el('btc-refresh').addEventListener('click', fetchBTC);

      // Auto refresh
      const intervalMs = 15000;
      el('btc-interval').textContent = (intervalMs/1000) + "s";
      render();
      fetchBTC();
      setInterval(fetchBTC, intervalMs);
    })();
  </script>
</body>
</html>